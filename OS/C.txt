---------------------------------------- PUNTERO -----------------------------
!!!!LAS VARIABLES (int a) SON SOLO ETIQUTAS DE DIRECCIONES EN MEMORIA, ES DECIR: a == hx03123, es solo un alias para que sepamos donde está la variable con un nombre humano. 
Es una variable que almacena una direccion en memoria. 

Si "a" es la ruta, ponerle el * es seguir la ruta hasta llegar al destino.

El nivel de exploración
1. Sin el asterisco (a)
Te quedas parado en la puerta. Solo miras el número de la casa.

En C: a

En ASM: MOV EAX, EBX (suponiendo que EBX tiene la dirección).

Resultado: Tienes la dirección.

2. Con un asterisco (*a)
Dás ese "paso más" que mencionas. Entras a la casa y ves qué hay en los cajones.

En C: *a

En ASM: MOV EAX, [EBX] (los corchetes son ese "paso más").

Resultado: Tienes el dato.

¿Y si hubiera dos asteriscos? (**a)
Solo por curiosidad, para que veas que tu lógica de "explorar un paso más" es infalible: Si tienes un puntero a otro puntero (un int **a), entonces:

a: El mapa para encontrar el segundo mapa.

*a: Sigues el primer mapa y encuentras el segundo mapa (otra dirección).

**a: Sigues el segundo mapa y finalmente encuentras el tesoro (el número).

En resumen: Cada * que agregas es un "salto" adicional que le pides a la CPU que haga en la memoria RAM.







**** Addres of & ****: 
1. numero: Es el valor (el 25).
2. &numero: Es la ubicación en la RAM donde el compilador guardó ese 25 (ejemplo: 0x100).






----------------------------------------- HEAP Y STACK --------------------------------------------
**** Stack ****: 
-El stack es lineal ordenado y crece hacia abajo, lo que significa que es extremadamente rápido ya que se consulta restando, pero es memoria limitada, si me paso con cosas muy grandes o recursion entonces puedo generar un stack over flow. 
- Su idea es de ir poniendo ladrillos, es medio rigido cuando quiero quitar algo tengo que desmontar todo. Siempre tengo que reescribir las variables
-El compilador lo usa para varibles declaradas dentro de funciones: int[10] 



**** heap (monton) ****: 
- Sirve como un pedazo de memoria mas desordenado (fragmentado) en donde se puede agarrar memoria de cualquier parte, tiene mas espacio que el stack. 
- Sirve cuando usamos malloc()
- Su idea es ser un campo comun donde puedo dejar cosas que no se pierden ni reescriben. 



**** Por que Heap en vez de Stack ****: 

1. Persistencia de los datos (Vida útil)
En el Stack, la memoria está ligada al flujo de ejecución; cuando una función termina y se ejecuta la instrucción RET en ensamblador, el puntero de pila (SP) se desplaza y el marco de memoria de esa función se considera libre, destruyendo lógicamente todo lo que había dentro. El Heap, en cambio, permite que los datos sobrevivan independientemente de las funciones. Esto es vital cuando necesitas crear un objeto o estructura en una función y seguir utilizándolo en otras partes del programa mucho tiempo después de que la función original haya finalizado. Sin el Heap, los datos morirían antes de poder ser procesados por el resto del código.

2. Flexibilidad de tamaño y redimensión
El Stack es una estructura rígida y contigua; para que una variable crezca, tendría que desplazar a todas las variables que se apilaron después de ella, lo cual es ineficiente y costoso para la CPU. En el Heap, al ser un espacio de memoria "desordenado" o fragmentado, no existe esa presión de vecindad. Si un bloque de memoria necesita hacerse más grande (usando realloc), el sistema simplemente busca un nuevo hueco con el tamaño suficiente en cualquier otra parte del "montón" y actualiza el puntero. Esto permite manejar estructuras de datos dinámicas, como listas o arreglos que crecen según la necesidad del usuario en tiempo de ejecución.

3. Compartición en sistemas multi-hilo
En la arquitectura moderna, cada hilo (thread) de un programa tiene su propio Stack privado para gestionar sus llamadas a funciones y variables locales de forma segura y rápida. Si toda la RAM fuera un solo Stack, sería imposible que dos hilos compartieran información de manera eficiente sin corromper el orden de las llamadas del otro. El Heap actúa como una zona de memoria compartida o "terreno neutral": un hilo puede reservar memoria, escribir datos en ella y simplemente pasarle el puntero a otro hilo para que lo lea. Esto facilita la comunicación y el trabajo en paralelo sin interferir con el flujo de ejecución individual de cada hilo.


-------------------------------------------- MALLOC() -----------------------------------------------------------------------------------------------
malloc(numero de bytes para alocar), lo aloca en el heap -> devuelve una direccion en memoria 





------------------- **** Errors ****: 

si la ram está llena o hubo un error malloc devuelve NULL: 

if (a == NULL) {
    perror("Error: No hay memoria suficiente.\n");
    return -1; // Terminar el programa o manejar el error
}
  
