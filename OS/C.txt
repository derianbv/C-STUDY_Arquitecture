------------------------------- LIBRERIAS ------------------------
Cuando hago algo como #include <stdio.h> lo unico que hace el compilador es copiar todo el codigo del archivo header (.h) lo copie al comienzo de mi archivo,
por esto puedo usar variables o funciones sin usar namespacing como: archivo.run(), sino solo run() porque es como si estuviera escrita en la parte de arriba 



<stdio.h>: printf, scanf
<stdlib.h>: malloc, exit



----------------------------- DEFINE -------------------------------------

#define (Macros del Preprocesador), NO OCUPAN ESPACIO EN MEMORIA, son variables constantes que el procesador busca en el codigo y remplaza por su valor asignado, es decir, si tengo:
#define LIST_QUEUE 400, no puedo en el codigo hacer LIST_QUEUE = 4444. 

---------------------------------------- PUNTERO -----------------------------
!!!!LAS VARIABLES (int a) SON SOLO ETIQUTAS DE DIRECCIONES EN MEMORIA, ES DECIR: a == hx03123, es solo un alias para que sepamos donde está la variable con un nombre humano. 
Es una variable que almacena una direccion en memoria. 

Si "a" es la ruta, ponerle el * es seguir la ruta hasta llegar al destino.

El nivel de exploración
1. Sin el asterisco (a)
Te quedas parado en la puerta. Solo miras el número de la casa.

En C: a

En ASM: MOV EAX, EBX (suponiendo que EBX tiene la dirección).

Resultado: Tienes la dirección.

2. Con un asterisco (*a)
Dás ese "paso más" que mencionas. Entras a la casa y ves qué hay en los cajones.

En C: *a

En ASM: MOV EAX, [EBX] (los corchetes son ese "paso más").

Resultado: Tienes el dato.

¿Y si hubiera dos asteriscos? (**a)
Solo por curiosidad, para que veas que tu lógica de "explorar un paso más" es infalible: Si tienes un puntero a otro puntero (un int **a), entonces:

a: El mapa para encontrar el segundo mapa.

*a: Sigues el primer mapa y encuentras el segundo mapa (otra dirección).

**a: Sigues el segundo mapa y finalmente encuentras el tesoro (el número).

En resumen: Cada * que agregas es un "salto" adicional que le pides a la CPU que haga en la memoria RAM.







**** Addres of & ****: 
1. numero: Es el valor (el 25).
2. &numero: Es la ubicación en la RAM donde el compilador guardó ese 25 (ejemplo: 0x100).






----------------------------------------- HEAP Y STACK --------------------------------------------
**** Stack ****: 
-El stack es lineal ordenado y crece hacia abajo, lo que significa que es extremadamente rápido ya que se consulta restando, pero es memoria limitada, si me paso con cosas muy grandes o recursion entonces puedo generar un stack over flow. 
- Su idea es de ir poniendo ladrillos, es medio rigido cuando quiero quitar algo tengo que desmontar todo. Siempre tengo que reescribir las variables
-El compilador lo usa para varibles declaradas dentro de funciones: int[10] 



**** heap (monton) ****: 
- Sirve como un pedazo de memoria mas desordenado (fragmentado) en donde se puede agarrar memoria de cualquier parte, tiene mas espacio que el stack. 
- Sirve cuando usamos malloc()
- Su idea es ser un campo comun donde puedo dejar cosas que no se pierden ni reescriben. 



**** Por que Heap en vez de Stack ****: 

1. Persistencia de los datos (Vida útil)
En el Stack, la memoria está ligada al flujo de ejecución; cuando una función termina y se ejecuta la instrucción RET en ensamblador, el puntero de pila (SP) se desplaza y el marco de memoria de esa función se considera libre, destruyendo lógicamente todo lo que había dentro. El Heap, en cambio, permite que los datos sobrevivan independientemente de las funciones. Esto es vital cuando necesitas crear un objeto o estructura en una función y seguir utilizándolo en otras partes del programa mucho tiempo después de que la función original haya finalizado. Sin el Heap, los datos morirían antes de poder ser procesados por el resto del código.

2. Flexibilidad de tamaño y redimensión
El Stack es una estructura rígida y contigua; para que una variable crezca, tendría que desplazar a todas las variables que se apilaron después de ella, lo cual es ineficiente y costoso para la CPU. En el Heap, al ser un espacio de memoria "desordenado" o fragmentado, no existe esa presión de vecindad. Si un bloque de memoria necesita hacerse más grande (usando realloc), el sistema simplemente busca un nuevo hueco con el tamaño suficiente en cualquier otra parte del "montón" y actualiza el puntero. Esto permite manejar estructuras de datos dinámicas, como listas o arreglos que crecen según la necesidad del usuario en tiempo de ejecución.

3. Compartición en sistemas multi-hilo
En la arquitectura moderna, cada hilo (thread) de un programa tiene su propio Stack privado para gestionar sus llamadas a funciones y variables locales de forma segura y rápida. Si toda la RAM fuera un solo Stack, sería imposible que dos hilos compartieran información de manera eficiente sin corromper el orden de las llamadas del otro. El Heap actúa como una zona de memoria compartida o "terreno neutral": un hilo puede reservar memoria, escribir datos en ella y simplemente pasarle el puntero a otro hilo para que lo lea. Esto facilita la comunicación y el trabajo en paralelo sin interferir con el flujo de ejecución individual de cada hilo.


-------------------------------------------- MALLOC() -----------------------------------------------------------------------------------------------
malloc(numero de bytes para alocar), lo aloca en el heap -> devuelve una direccion en memoria 





------------------- **** Errors ****: 

si la ram está llena o hubo un error malloc devuelve NULL: 

if (a == NULL) {
    perror("Error: No hay memoria suficiente.\n");
    return -1; // Terminar el programa o manejar el error
}


-------------------------------------------- LEER DE ARCHIVOS --------------------------------------------------------------------------------------
EPP:
<stdio.h> tiene la struct de FILE, a la que para usar archivos vamos a estar apuntando con un puntero: 

File* ptrArchivo; // se guardan 64 bits en stack para guardar la direccion de un dato tipo FILE, la etiqueta de esos 64 bites es ptrArchivo. 

Luego se guarda en la cajita de ptrArchivo la direccion en memoria del File que retorna fopen (Null si hubo error); 

ptrArchivo = fopen("archivo.txt","w");   (archivoname, tipo de lectura). 

Confirmar error: 


if (f == NULL) {
        printf("Error: fopen retornó NULL (0x0)\n");
    } else {
        // Imprimimos la dirección de memoria en hexadecimal
        printf("fopen tuvo éxito y retornó la dirección: %p\n", (void*)f);


MODIFICARLOS: 

Los archivos son una fila india de 1s y 0s, por ejemplo en un archivo de  1 KB, tienes exactamente 8,192 bits (0 y 1) pegados uno tras otro. La codificacion de estos 0 y 1 cambian dependiendo de como abra el archivo y su extensión: 


Si lo abres como Texto (fprintf, fscanf): C interpreta cada grupo de 8 bits según una tabla (como ASCII o UTF-8), El byte 01000001 se traduce al número 65, que en pantalla se ve como una 'A'.
Si lo abres como Binario (fwrite, fread): C no intenta interpretar nada. Simplemente copia los bits tal cual de la memoria RAM al disco. Esto se usa para imágenes, ejecutables o bases de datos.


size_t fwrite(const void *ptr, size_t tamano, size_t cantidad, FILE *flujo);
Los 4 elementos que debes entregarle:

    const void *ptr (¿QUÉ envío?):
    Es la dirección de memoria de los datos que quieres escribir. Puede ser un array, una estructura o una variable simple. Se usa void * porque a fwrite no le importa si estás enviando fotos, números o texto; solo ve bytes.

    size_t tamano (¿Cuánto mide cada pieza?):
    El tamaño en bytes de un solo elemento de los que vas a enviar. Normalmente usamos sizeof() para no equivocarnos.

        Ejemplo: sizeof(int) o sizeof(char).

    size_t cantidad (¿Cuántas piezas envío?):
    El número de elementos. Si es un array de 10 enteros, aquí pones 10. Si es una sola variable, pones 1.

    FILE *flujo (¿A dónde lo envío?):
    El puntero que obtuviste con fopen. Es el "marcador" que sabe en qué parte de la fila india de bits debe escribir.

WRITE RETORNA UN DATO SIZE_T 



size_t fread(void *ptr, size_t tamano, size_t cantidad, FILE *flujo);

Los 4 argumentos de fread()

    void *ptr (¿DÓNDE lo guardo?):
    Es la dirección de memoria de la variable o array donde quieres que caigan los datos que vas a leer del archivo.

        Nota: Aquí no usas const porque esta vez la función sí va a modificar esa memoria (va a escribir en ella).

    size_t tamano (¿Cuánto mide cada pieza?):
    El tamaño en bytes de un solo elemento (usa sizeof).

    size_t cantidad (¿Cuántas piezas quiero traer?):
    El número de elementos que quieres leer.

    FILE *flujo (¿DE DÓNDE lo saco?):
    El puntero al archivo que abriste con fopen (usando "r", "rb", "r+", etc.).







!!!!!!!!!!!!!!!!!!!!!
La data (stream) empieza lit desde la posicion 0 de la fila ya que cuando hago fopen el sistema operativo hace el trabajo sucio de separar los datos con la metadata, en Linux el sistema de archivos guarda en Inodos la metadata de eso. 

Ahora, hay una excepción importante. Muchos formatos de archivo (como .JPG, .MP3 o .EXE) guardan su propia metadata dentro de la fila india de bytes, al principio. A esto se le llama Header (Cabecera).

Si abres un archivo .bmp (una imagen simple) en C:

    Los primeros 54 bytes son la "metadata interna" (ancho, alto, colores).

    A partir del byte 55, empiezan los colores de los píxeles (tus datos).

Para C, el byte 0 sigue siendo el inicio del Header. Si tú quieres leer solo los colores, tendrías que hacer:
Cuando tu cursor llega al byte número tamaño_del_archivo, la función feof(f) devuelve verdadero.

---------------------------------------------------------- ESTRUCTURAS --------------------------------------------------------------------
EPP: 
Las estructuras de C son como las listas de python, es la manera de agrupar datos de diferentes tipos. 

"""

struct Estudiante{
    char[50] nombre; //50 bytes  
    int edad; //4 bytes
    float nota; //4 bytes 
} 

Acá no se hace nada en memoria, solo se le avisa a la cpu que tiene que entender estos simbolos cuando aparezcan. 
"""


DECLARACION: 
Aca ya se le asignan espacios en memoria casi continuos, si no fuera por el Padding que guarda el tamaño de las variables en espacioes de memoria multiples a ellos: 

"""
struc Estudiante Santi;

Acá teoricamente devería guardar 58 bytes la estructura, pero como el procesador agarra de a 4 u 8 bytes a la vez (depende de la arquitectura del procesador) entonces siempre los deja en multiplos de cuatro a los datos, para 
solo tener que consultarlos una vez, (Va más rápido), por ejemplo, en la estructura de arriba se hace el sig padding (es como si fueran paginas de un libro, si una variable esta en la parte final de una pagina y el comienzo
de otra, entonces tendras que enviar esas dos paginas usando el bus da datos, cada pagina equivale a 4 bytes, empezando por el 0-3,4-7,8-11: 


struct Estudiante{
    char[50] nombre; //50 bytes  
    int edad; //4 bytes
    float nota; //4 bytes 
} 

Los datos se ponen en memoria en orden como yo los pongo, por eso dependiendo de como los ponga puedo ahorra ram. 

posiciones (1byte) | dato 
0: char 
(...)
49: char  (aca como agarra en un bus de  envio de datos de 4 en 4 bytes, el hardware tiene que hacer 50/4 consultas, es decir: 12.5 consultas (EL HARDWARE DESTESTA ESTOS DECIMALES PORQUE LOS TIENE QUE APROXIMAR AL TECHO (13), o leer 13 paginas.
50: padding (pag 13) 
51: padding (pag 13, 0-51 hay 52 paginas o 52 4 bytes (4*13). 
52: int (52 multiplo de 4)  
53: int
54: int
55: int
(56 - 59): 56 multiplo de 4 entonces inicia el float. 
60: libre para el sig numero porque 60 es multiplo de 4.

Peso total de bytes: 0-59: 60 bytes. 


EJEMPLO:




#include <stdio.h>

int main()
{
    

struct Estudiante{
    char nombre[50]; //50 bytes  
    int edad; //4 bytes
    float nota; //4 bytes 
};


struct Estudiante santi; 

printf("tamaño en bytes de la estructura: %zu bytes", sizeof(santi)); 

    
    
    return 0;
}


OUT: 
tamaño en bytes de la estructura: 60 bytes


EN GENERAL ESTA OPTIMIZADO SI LOS DATOS GRANDES ESTAN PRIMERO 

"""


INCIALIZACION: 
-RAPIDA: struct Estudiante a2 = {"Ana", 20, 9.8};

-LENTA (Usando punto). 

strcpy(alumno1.nombre, "Carlos");
    alumno1.edad = 21;
    alumno1.promedio = 9.5;


-SI ES UN PUNTERO A UNA STRUCT (-> es atajo para desferenciar):
(*puntero).miembro == puntero->miembro














  
