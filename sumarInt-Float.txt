Idea, pasar de este cÃ³digo: 

#include <stdio.h>
#include <stdint.h>

float x=3.14,y=4.2;
int8_t q=5,v=0,w=9;

int main()
{
    
    x=x+q;
    
    x=x+y;

    v=x;
    
    v=v+w;
    
    printf("x = %f\n",x);
    printf("v = %d\n",v);

    return 0;
}


a ensamblador: --------------------------------------------------------------------------------------------------------------------------------------------
Los nÃºmeros flotantes no se pueden operar en el ALU (ARITMETI LOGIC UNIT), esta parte del pc es la que trabaja con los registros de %eax %ebx %ecx, sino, los maneja una unidad que se llama Floating Point Unit, y para esta unidad se utiliza %xmm0 o %xmm1. Tambien
%eax tiene 32 bits, %mm0 tiene 128 bits. 

ğŸ§© Resumen rÃ¡pido:
ğŸ‘‰ Los enteros usan %eax, %ebx porque trabajan con la ALU.
ğŸ‘‰ Los flotantes usan %xmm0, %xmm1 porque se procesan en la FPU/SSE.

movsbl MOVe con Sign extension a un Byte para convertirlo en un Long (32 bits).
mov y el signed byte a long

â— Problema real:
mov $-4, %al     # al = 11111100
mov %al, %eax    # eax = ???????? ???????? ???????? 11111100



â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   %rax       â”‚ 64 bits (registro completo en x86-64)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   %eax       â”‚ 32 bits (parte baja de %rax)
â”œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ %ah  â”‚ %al   â”‚ 8 bits altos y bajos de los 16 bits bajos de %ax
â”œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   %ax        â”‚ 16 bits (parte baja de %eax)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Para las funciones de call + funcion, este es el orden para buscar cosas por el call: 

| Tipo de argumento      | Registro donde lo busca |
| ---------------------- | ----------------------- |
| 1er `double` / `float` | `%xmm0`                 |
| 2do `double` / `float` | `%xmm1`                 |
| 1er `int` / puntero    | `%rdi`                  |
| 2do `int`              | `%rsi`                  |
| etc.                   | ...                     |



Tipo de funciÃ³n	Ejemplo	Â¿Sabe cuÃ¡ntos argumentos recibe?
Fija	void saluda(int a, float b)	âœ… SÃ­, el compilador lo sabe
VariÃ¡dica	int printf(const char*, ...)	âŒ No, el compilador NO lo sabe, los ... implica que pueden haber mas argumentos 


En particular:
âš ï¸ Cuando llamas a una funciÃ³n variÃ¡dica y pasas argumentos de punto flotante (float o double), debes:

Pasarlos por los registros %xmm0, %xmm1, etc.

Y poner en %eax cuÃ¡ntos %xmm estÃ¡s usando.


| FunciÃ³n    | Firma en C                                                   | Â¿VariÃ¡dica? | Â¿Necesita `mov $N, %eax` antes de `call`?       |
| ---------- | ------------------------------------------------------------ | ----------- | ----------------------------------------------- |
| `printf`   | `int printf(const char* fmt, ...)`                           | âœ… SÃ­        | âœ… **SÃ­** (ej. `mov $1, %eax` si pasas un float) |
| `scanf`    | `int scanf(const char* fmt, ...)`                            | âœ… SÃ­        | âœ… **SÃ­**                                        |
| `fprintf`  | `int fprintf(FILE* stream, const char* fmt, ...)`            | âœ… SÃ­        | âœ… **SÃ­**                                        |
| `sprintf`  | `int sprintf(char* str, const char* fmt, ...)`               | âœ… SÃ­        | âœ… **SÃ­**                                        |
| `snprintf` | `int snprintf(char* str, size_t size, const char* fmt, ...)` | âœ… SÃ­        | âœ… **SÃ­**                                        |
| `logf`     | `void logf(const char* fmt, ...)`                            | âœ… SÃ­        | âœ… **SÃ­**                                        |
| `puts`     | `int puts(const char* s)`                                    | âŒ No        | âŒ No                                            |
| `exit`     | `void exit(int code)`                                        | âŒ No        | âŒ No                                            |
| `malloc`   | `void* malloc(size_t size)`                                  | âŒ No        | âŒ No                                            |
| `free`     | `void free(void* ptr)`                                       | âŒ No        | âŒ No                                            |
| `strlen`   | `size_t strlen(const char* s)`                               | âŒ No        | âŒ No                                            |
| `fopen`    | `FILE* fopen(const char* path, const char* mode)`            | âŒ No        | âŒ No                                            |
| `memcpy`   | `void* memcpy(void* dest, const void* src, size_t n)`        | âŒ No        | âŒ No                                            |
| `read`     | `ssize_t read(int fd, void* buf, size_t count)`              | âŒ No        | âŒ No                                            |













------------------------------ RESULTADO: ------------------------------------------------------------


.data
    x: .float 3.14
    y: .float 4.2
    q: .byte 5
    w: .byte 9
    v: .byte 0
    fmtx: .string "x = %f\n"
    fmtv: .string "v = %d\n"


.text
.global main
main:
    subq $8,%rsp

//    x=x+q;
    
    movsbl      q, %eax         
    cvtsi2ssl   %eax, %xmm1         // Convierte el entero en %eax a flotante de precisiÃ³n simple   
    movss       x, %xmm0                
    addss       %xmm1, %xmm0    
    movss       %xmm0, x     
//  x=x+y;
 
    movss y, %xmm1
    addss %xmm0, %xmm1
    movss %xmm1, x 
    
//    v=x; truncar el flotante 
    
    cvttss2sil %xmm1, %eax //convert y trunc ss 2 single integer large
    movb %al, v 
    
//     v=v+w;
    
    movb w, %bl 
    addb %bl, v
    
// imprimir 


    //printf("x = %f\n",x);
    //printf("v = %d\n",v);

//print x: 
    
    movss x, %xmm0 
    cvtss2sd %xmm0, %xmm0
    movl $fmtx, %edi 
    movl $1, %eax
    call printf 

//print v: 

  movsbl v, %esi 
  movl $fmtv, %edi 
  movl $0, %eax 
  call printf 
    
//
	xor	%eax, %eax
	addq $8,%rsp
	ret

