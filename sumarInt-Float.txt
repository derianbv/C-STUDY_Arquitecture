Idea, pasar de este cÃ³digo: 

#include <stdio.h>
#include <stdint.h>

float x=3.14,y=4.2;
int8_t q=5,v=0,w=9;

int main()
{
    
    x=x+q;
    
    x=x+y;

    v=x;
    
    v=v+w;
    
    printf("x = %f\n",x);
    printf("v = %d\n",v);

    return 0;
}


a ensamblador: --------------------------------------------------------------------------------------------------------------------------------------------
Los nÃºmeros flotantes no se pueden operar en el ALU (ARITMETI LOGIC UNIT), esta parte del pc es la que trabaja con los registros de %eax %ebx %ecx, sino, los maneja una unidad que se llama Floating Point Unit, y para esta unidad se utiliza %xmm0 o %xmm1. Tambien
%eax tiene 32 bits, %mm0 tiene 128 bits. 

ğŸ§© Resumen rÃ¡pido:
ğŸ‘‰ Los enteros usan %eax, %ebx porque trabajan con la ALU.
ğŸ‘‰ Los flotantes usan %xmm0, %xmm1 porque se procesan en la FPU/SSE.

movsbl MOVe con Sign extension a un Byte para convertirlo en un Long (32 bits).
mov y el signed byte a long

â— Problema real:
mov $-4, %al     # al = 11111100
mov %al, %eax    # eax = ???????? ???????? ???????? 11111100



â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   %rax       â”‚ 64 bits (registro completo en x86-64)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   %eax       â”‚ 32 bits (parte baja de %rax)
â”œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ %ah  â”‚ %al   â”‚ 8 bits altos y bajos de los 16 bits bajos de %ax
â”œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   %ax        â”‚ 16 bits (parte baja de %eax)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


Para las funciones de call + funcion, este es el orden para buscar cosas por el call: 

| Tipo de argumento      | Registro donde lo busca |
| ---------------------- | ----------------------- |
| 1er `double` / `float` | `%xmm0`                 |
| 2do `double` / `float` | `%xmm1`                 |
| 1er `int` / puntero    | `%rdi`                  |
| 2do `int`              | `%rsi`                  |
| etc.                   | ...                     |



Tipo de funciÃ³n	Ejemplo	Â¿Sabe cuÃ¡ntos argumentos recibe?
Fija	void saluda(int a, float b)	âœ… SÃ­, el compilador lo sabe
VariÃ¡dica	int printf(const char*, ...)	âŒ No, el compilador NO lo sabe, los ... implica que pueden haber mas argumentos 


En particular:
âš ï¸ Cuando llamas a una funciÃ³n variÃ¡dica y pasas argumentos de punto flotante (float o double), debes:

Pasarlos por los registros %xmm0, %xmm1, etc.

Y poner en %eax cuÃ¡ntos %xmm estÃ¡s usando.
